# This file carries information about MOS6502 CPU's instruction set.
#
# Data contained here is used to autogenerate instruction decoding
# logic for the emulator.
#
# The meaning of each column is as follows:
#   1. Opcode of the instruction in hex.
#   2. Whenever the instruction only reads memory, only writes, or both.
#   3. Mnemonic of the instruction.
#   4. Addressing mode of the instruction's operands; two addressing
#      modes can be given, separated by a pipe, in which case the one on the
#      left is used for generating decoding logic for the emulator, while
#      the one on the right is used for the pretty printer.
#   5. Piece of code that will handle given instruction.
#
0x65 R   adc    abs_zp              adc()
0x6D R   adc    abs                 adc()
0x75 R   adc    addx_zp             adc()
0x69 R   adc    imm8                adc()
0x79 R   adc    addy                adc()
0x7D R   adc    addx                adc()
0x71 R   adc    indexed_indirect    adc()
0x61 R   adc    indirect_indexed    adc()
0x25 R   and    abs_zp              and()
0x2D R   and    abs                 and()
0x35 R   and    addx_zp             and()
0x29 R   and    imm8                and()
0x3D R   and    addx                and()
0x39 R   and    addy                and()
0x21 R   and    indirect_indexed    and()
0x31 R   and    indexed_indirect    and()
0x06 RW  asl    abs_zp              asl()
0x0E RW  asl    abs                 asl()
0x16 RW  asl    addx_zp             asl()
0x1E RW  asl    addx_EC             asl()
0x0A RW  asl    reg_a               asl()
0xB0 R   bcs    imm8                branch( StatusFlag::Carry, true )
0x90 R   bcc    imm8                branch( StatusFlag::Carry, false )
0xF0 R   beq    imm8                branch( StatusFlag::Zero, true )
0xD0 R   bne    imm8                branch( StatusFlag::Zero, false )
0x30 R   bmi    imm8                branch( StatusFlag::Sign, true )
0x10 R   bpl    imm8                branch( StatusFlag::Sign, false )
0x50 R   bvc    imm8                branch( StatusFlag::Overflow, false )
0x70 R   bvs    imm8                branch( StatusFlag::Overflow, true )
0x24 R   bit    abs_zp              bit()
0x2C R   bit    abs                 bit()
# BRK needs imm8 since it increments PC when fetching the throwaway byte.
0x00 _   brk    imm8|_              brk()
0x18 _   clc    _                   clr( StatusFlag::Carry )
0xD8 _   cld    _                   clr( StatusFlag::BCDMode )
0x58 _   cli    _                   clr( StatusFlag::IRQDisable )
0xB8 _   clv    _                   clr( StatusFlag::Overflow )
0xC5 R   cmp    abs_zp              compare( A )
0xCD R   cmp    abs                 compare( A )
0xD5 R   cmp    addx_zp             compare( A )
0xC9 R   cmp    imm8                compare( A )
0xD9 R   cmp    addy                compare( A )
0xDD R   cmp    addx                compare( A )
0xC1 R   cmp    indirect_indexed    compare( A )
0xD1 R   cmp    indexed_indirect    compare( A )
0xE4 R   cpx    abs_zp              compare( X )
0xEC R   cpx    abs                 compare( X )
0xE0 R   cpx    imm8                compare( X )
0xC4 R   cpy    abs_zp              compare( Y )
0xCC R   cpy    abs                 compare( Y )
0xC0 R   cpy    imm8                compare( Y )
0xC6 RW  dec    abs_zp              incdec( -1 )
0xCE RW  dec    abs                 incdec( -1 )
0xD6 RW  dec    addx_zp             incdec( -1 )
0xDE RW  dec    addx_EC             incdec( -1 )
0xCA RW  dex    reg_x               incdec( -1 )
0x88 RW  dey    reg_y               incdec( -1 )
0x45 R   eor    abs_zp              eor()
0x4D R   eor    abs                 eor()
0x55 R   eor    addx_zp             eor()
0x59 R   eor    addy                eor()
0x5D R   eor    addx                eor()
0x49 R   eor    imm8                eor()
0x51 R   eor    indexed_indirect    eor()
0x41 R   eor    indirect_indexed    eor()
0xE6 RW  inc    abs_zp              incdec( 1 )
0xEE RW  inc    abs                 incdec( 1 )
0xF6 RW  inc    addx_zp             incdec( 1 )
0xFE RW  inc    addx_EC             incdec( 1 )
0xE8 RW  inx    reg_x               incdec( 1 )
0xC8 RW  iny    reg_y               incdec( 1 )
# The operands of those three instructions are fetched manually in the emulator,
# that's why they all have imm8 set here.
0x6C ?   jmp    imm8|abs            jmp_abs()
0x4C ?   jmp    imm8|imm16          jmp_imm()
0x20 ?   jsr    imm8|imm16          jsr()
0xA5 R   lda    abs_zp              mov2reg( A )
0xAD R   lda    abs                 mov2reg( A )
0xB5 R   lda    addx_zp             mov2reg( A )
0xB9 R   lda    addy                mov2reg( A )
0xBD R   lda    addx                mov2reg( A )
0xA9 R   lda    imm8                mov2reg( A )
0xB1 R   lda    indexed_indirect    mov2reg( A )
0xA1 R   lda    indirect_indexed    mov2reg( A )
0xA6 R   ldx    abs_zp              mov2reg( X )
0xAE R   ldx    abs                 mov2reg( X )
0xB6 R   ldx    addy_zp             mov2reg( X )
0xA2 R   ldx    imm8                mov2reg( X )
0xBE R   ldx    addy                mov2reg( X )
0xA4 R   ldy    abs_zp              mov2reg( Y )
0xAC R   ldy    abs                 mov2reg( Y )
0xB4 R   ldy    addx_zp             mov2reg( Y )
0xBC R   ldy    addx                mov2reg( Y )
0xA0 R   ldy    imm8                mov2reg( Y )
0x46 RW  lsr    abs_zp              lsr()
0x4E RW  lsr    abs                 lsr()
0x56 RW  lsr    addx_zp             lsr()
0x5E RW  lsr    addx_EC             lsr()
0x4A RW  lsr    reg_a               lsr()
0xEA _   nop    _                   nop()
0x05 R   ora    abs_zp              ora()
0x0D R   ora    abs                 ora()
0x15 R   ora    addx_zp             ora()
0x09 R   ora    imm8                ora()
0x1D R   ora    addx                ora()
0x19 R   ora    addy                ora()
0x11 R   ora    indexed_indirect    ora()
0x01 R   ora    indirect_indexed    ora()
0x48 _   pha    _                   pha()
0x08 _   php    _                   php()
0x68 _   pla    _                   pla()
0x28 _   plp    _                   plp()
0x26 RW  rol    abs_zp              rol()
0x2E RW  rol    abs                 rol()
0x36 RW  rol    addx_zp             rol()
0x3E RW  rol    addx_EC             rol()
0x2A RW  rol    reg_a               rol()
0x66 RW  ror    abs_zp              ror()
0x6E RW  ror    abs                 ror()
0x76 RW  ror    addx_zp             ror()
0x7E RW  ror    addx_EC             ror()
0x6A RW  ror    reg_a               ror()
0x40 _   rti    _                   rti()
0x60 _   rts    _                   rts()
0xE5 R   sbc    abs_zp              sbc()
0xED R   sbc    abs                 sbc()
0xF5 R   sbc    addx_zp             sbc()
0xE9 R   sbc    imm8                sbc()
0xF9 R   sbc    addy                sbc()
0xFD R   sbc    addx                sbc()
0xE1 R   sbc    indirect_indexed    sbc()
0xF1 R   sbc    indexed_indirect    sbc()
0x38 _   sec    _                   set( StatusFlag::Carry )
0xF8 _   sed    _                   set( StatusFlag::BCDMode )
0x78 _   sei    _                   set( StatusFlag::IRQDisable )
0x85 W   sta    abs_zp              reg2mem( A )
0x8D W   sta    abs                 reg2mem( A )
0x95 W   sta    addx_zp             reg2mem( A )
0x99 W   sta    addy_EC             reg2mem( A )
0x9D W   sta    addx_EC             reg2mem( A )
0x91 W   sta    indexed_indirect_EC reg2mem( A )
0x81 W   sta    indirect_indexed_EC reg2mem( A )
0x86 W   stx    abs_zp              reg2mem( X )
0x8E W   stx    abs                 reg2mem( X )
0x96 W   stx    addy_zp             reg2mem( X )
0x84 W   sty    abs_zp              reg2mem( Y )
0x8C W   sty    abs                 reg2mem( Y )
0x94 W   sty    addx_zp             reg2mem( Y )
0xAA R   tax    reg_a               mov2reg( X )
0xA8 R   tay    reg_a               mov2reg( Y )
0xBA R   tsx    reg_sp              mov2reg( X )
0x8A R   txa    reg_x               mov2reg( A )
0x9A R   txs    _                   txs()
0x98 R   tya    reg_y               mov2reg( A )

# Unofficial opcodes.
0xA7 R   lax    abs_zp              mov2reg( A ); mov2reg( X )
0xB7 R   lax    addy_zp             mov2reg( A ); mov2reg( X )
0xA3 R   lax    indirect_indexed    mov2reg( A ); mov2reg( X )
0xB3 R   lax    indexed_indirect    mov2reg( A ); mov2reg( X )
0xAF R   lax    abs                 mov2reg( A ); mov2reg( X )
0xBF R   lax    addy                mov2reg( A ); mov2reg( X )
0x87 W   sax    abs_zp              reg2mem_and( A, X )
0x97 W   sax    addx_zp             reg2mem_and( A, X )
0x83 W   sax    indirect_indexed    reg2mem_and( A, X )
0x8F W   sax    abs                 reg2mem_and( A, X )

# Alternative name: SBX, SAX
0xCB R   axs    imm8                axs()
